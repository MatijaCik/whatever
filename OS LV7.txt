1. Koristeći POSIX Threads biblioteku kreirajte program koji kreira i pokreće 3 neovisne niti: jednu nit za ispis najvećeg elementa polja, drugu za ispis najmanjeg elementa polja
i treću za ispis aritmetičke sredine elemenata polja. Polje inicijalizirajte kao globalnu varijablu.

#include <stdio.h>
#include <pthread.h>
#define ARRAY_SIZE 10

int array[ARRAY_SIZE] = {5, 4, 2, 6, 3, 7, 9, 4, 8, 8};

void *find_max(void *arg) {
	int max = array[0];
	int i = 0;
	for (i=0; i < ARRAY_SIZE; i++) {
		if (array[i] > max) {
		max = array[i];
	}
}

printf("Najveci element polja: %d\n", max);
pthread_exit(NULL);
}

void *find_min(void *arg) {
	int min = array[0];
	int i = 0;
	for (i = 0; i < ARRAY_SIZE; i++) {
		if (array[i] < min) {
		min = array[i];
	}
}

printf("Najmanji element polja: %d\n", min);
pthread_exit(NULL);
}

void *find_avg(void *arg) {
int sum = 0;
int i = 0;
for (i = 0; i < ARRAY_SIZE; i++) {
	sum += array[i];
}

printf("Aritmeticka sredina elemenata polja: %.2f\n", (float)sum / ARRAY_SIZE);
pthread_exit(NULL);
}

int main() {
pthread_t tid1, tid2, tid3;

pthread_create(&tid1, NULL, find_max, NULL);
pthread_create(&tid2, NULL, find_min, NULL);
pthread_create(&tid3, NULL, find_avg, NULL);

pthread_join(tid1, NULL);
pthread_join(tid2, NULL);
pthread_join(tid3, NULL);

return 0;
}

2. Koristeći POSIX Threads biblioteku napravite program koji kreira i pokreće dvije niti: prva funkcija neprestano kvadrira sve elemente nekog polja, dok druga nit neprestano
korjenuje sve elemente nekog polja. Obje niti ispisuju polje nakon izvođenja operacije kvadriranja, odnosno korjenovanja te odlaze na spavanje jednu sekundu (sleep(1)).
Polje inicijalizirajte kao globalnu varijablu. 

#include <stdio.h>
#include <pthread.h>
#include <math.h>
#include <unistd.h>
#define ARRAY_SIZE 5

int array[ARRAY_SIZE] = {6, 5, 4, 3, 2};

void *square(void *arg) {
	while(1) {
	int i = 0;
	for (i=0; i < ARRAY_SIZE; i++) {
		array[i] *= array[i];
	}

	printf("Polje nakon kvadriranja: ");
	for (i = 0; i < ARRAY_SIZE; i++) {
		printf("%d ", array[i]);
	}
	printf("\n");

	sleep(1);
	}
}

void *square_root(void *arg) {
	while(1) {
	int i = 0;
	for (i = 0; i < ARRAY_SIZE; i++) {
		array[i] = sqrt(array[i]);
}

printf("Polje nakon korjenovanja: ");
for (i = 0; i < ARRAY_SIZE; i++) {
	printf("%d ", array[i]);
}
printf("\n");

sleep(1);
}
}

int main() {
	pthread_t tid1, tid2;

	pthread_create(&tid1, NULL, square, NULL);
	pthread_create(&tid2, NULL, square_root, NULL);

	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);

	return 0;
}

3. Program iz zadataka 2 nadopunite tako da implementirate međusobno isključivanje dviju niti pomoću Dekkerova algoritma.

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <math.h>

double array[] = {1.0, 2.0, 3.0, 4.0, 5.0};
int array_size = sizeof(array) / sizeof(array[0]);

volatile int turn = 0;
volatile int flag[2] = {0, 0};

void *square_elements(void *arg) {
    while (1) {
        flag[0] = 1;
        while (flag[1]) {
            if (turn != 0) {
                flag[0] = 0;
                while (turn != 0);
                flag[0] = 1;
            }
        }

        
        for (int i = 0; i < array_size; i++) {
            array[i] = array[i] * array[i];
        }
        printf("Kvadrirani elementi: ");
        for (int i = 0; i < array_size; i++) {
            printf("%.2f ", array[i]);
        }
        printf("\n");

   
        turn = 1;
        flag[0] = 0;

        sleep(1);
    }
    pthread_exit(NULL);
}

void *sqrt_elements(void *arg) {
    while (1) {
        flag[1] = 1;
        while (flag[0]) {
            if (turn != 1) {
                flag[1] = 0;
                while (turn != 1);
                flag[1] = 1;
            }
        }


        for (int i = 0; i < array_size; i++) {
            array[i] = sqrt(array[i]);
        }
        printf("Korjenovani elementi: ");
        for (int i = 0; i < array_size; i++) {
            printf("%.2f ", array[i]);
        }
        printf("\n");


        turn = 0;
        flag[1] = 0;

        sleep(1);
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, square_elements, NULL);
    pthread_create(&thread2, NULL, sqrt_elements, NULL);


    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}

4. Program iz zadataka 2 nadopunite tako da implementirate međusobno isključivanje dviju niti pomoću Petersonova algoritma.

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <math.h>

double array[] = {1.0, 2.0, 3.0, 4.0, 5.0};
int array_size = sizeof(array) / sizeof(array[0]);

volatile int turn;
volatile int flag[2] = {0, 0};

void *square_elements(void *arg) {
    while (1) {
        flag[0] = 1;
        turn = 1;
        while (flag[1] && turn == 1);

        for (int i = 0; i < array_size; i++) {
            array[i] = array[i] * array[i];
        }
        printf("Kvadrirani elementi: ");
        for (int i = 0; i < array_size; i++) {
            printf("%.2f ", array[i]);
        }
        printf("\n");

        flag[0] = 0;

        sleep(1);
    }
    pthread_exit(NULL);
}

void *sqrt_elements(void *arg) {
    while (1) {
        flag[1] = 1;
        turn = 0;
        while (flag[0] && turn == 0);

        for (int i = 0; i < array_size; i++) {
            array[i] = sqrt(array[i]);
        }
        printf("Korjenovani elementi: ");
        for (int i = 0; i < array_size; i++) {
            printf("%.2f ", array[i]);
        }
        printf("\n");
        flag[1] = 0;

        sleep(1);
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, square_elements, NULL);
    pthread_create(&thread2, NULL, sqrt_elements, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}

















