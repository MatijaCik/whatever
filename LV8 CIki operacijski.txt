1. Na dnu je dan primjer vi코enitnog programa implementiranog u programskom jeziku C,
u kojem jedna nit izvodi funkciju firstFunction, a druga nit funkciju secondFunction.
Prva funkcija pove캖ava vrijednost varijable1, a smanjuje vrijednost varijable2, dok
druga nit radi obrnuto. Ukoliko vrijednost varijable1 postane ve캖a od vrijednosti
varijable2, mo쬰 se izvoditi samo druga nit. Tako캠er, ako vrijednost varijable2 postane
ve캖a od vrijednosti varijable1, mo쬰 se izvoditi samo prva nit. Va코 zadatak je dovr코iti
programski kod tako da omogu캖ite sinkronizaciju me캠u nitima koriste캖i mutekse i
uvjetne varijable iz biblioteke pthreads. Kopirajte programski kod i objasnite svoje
rje코enje. Kod kompajliranja dodajte opciju -lm zbog matemati캜ke biblioteke.

nano zad1.c


#include <stdio.h>
#include <pthread.h>
#include <math.h>
#include <stdlib.h>  // za abs
#include <unistd.h>  // za sleep

float variable1 = 10;
float variable2 = 9;

pthread_mutex_t mutex;
pthread_cond_t cond;

void *firstFunction() {
    while (1) {
        pthread_mutex_lock(&mutex);
        while (variable1 > variable2) {
            pthread_cond_wait(&cond, &mutex);
        }

        variable1 = 3 * variable1 * variable1 + 4 * variable1 - 3;
        variable2 = sqrt(fabs(variable2)) - 4;
        printf("Thread1: %.2f %.2f\n", variable1, variable2);

        pthread_cond_signal(&cond);
        pthread_mutex_unlock(&mutex);
        sleep(1);
    }
    pthread_exit(0);
}

void *secondFunction() {
    while (1) {
        pthread_mutex_lock(&mutex);
        while (variable2 > variable1) {
            pthread_cond_wait(&cond, &mutex);
        }

        variable1 = sqrt(fabs(variable1)) - 4;
        variable2 = 3 * variable2 * variable2 + 4 * variable2 - 3;
        printf("Thread2: %.2f %.2f\n", variable1, variable2);

        pthread_cond_signal(&cond);
        pthread_mutex_unlock(&mutex);
        sleep(1);
    }
    pthread_exit(0);
}

int main(void) {
    pthread_t thread1, thread2;

    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);

    pthread_create(&thread1, NULL, firstFunction, NULL);
    pthread_create(&thread2, NULL, secondFunction, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);

    return 0;
}


gcc zad1.c -o zad1 -lpthread -lm
 ./zad1
Thread2: -0.84 276.00
Thread1: -4.25 12.61
Thread1: 34.09 -0.45
Thread2: 1.84 -4.19
Thread2: -2.64 32.92
Thread1: 7.40 1.74
Thread2: -1.28 13.01
Thread1: -3.20 -0.39
Thread1: 14.97 -3.37
Thread2: -0.13 17.64
Thread1: -3.47 0.20
Thread1: 19.31 -3.55
Thread2: 0.39 20.67
Thread1: -0.96 0.55
Thread1: -4.08 -3.26
Thread1: 30.55 -2.19
Thread2: 1.53 2.67



2. U programskom kodu iz zadatka 1 zamijenite sinkronizaciju pomo캖u muteksa i
uvjetnih varijabli sa sinkronizacijom pomo캖u semafora.

nano zad2.c


#include <stdio.h>
#include <pthread.h>
#include <math.h>
#include <stdlib.h>
#include <unistd.h>
#include <semaphore.h>

float variable1 = 10;
float variable2 = 9;

sem_t semFirst;
sem_t semSecond;

void *firstFunction() {
    while (1) {
        sem_wait(&semFirst);

        if (variable2 >= variable1) {
            variable1 = 3 * variable1 * variable1 + 4 * variable1 - 3;
            variable2 = sqrt(fabs(variable2)) - 4;
            printf("Thread1: %.2f %.2f\n", variable1, variable2);
        }

        sem_post(&semSecond);
        sleep(1);
    }
    pthread_exit(0);
}

void *secondFunction() {
    while (1) {
        sem_wait(&semSecond);

        if (variable1 >= variable2) {
            variable1 = sqrt(fabs(variable1)) - 4;
            variable2 = 3 * variable2 * variable2 + 4 * variable2 - 3;
            printf("Thread2: %.2f %.2f\n", variable1, variable2);
        }

        sem_post(&semFirst);
        sleep(1);
    }
    pthread_exit(0);
}

int main(void) {
    pthread_t thread1, thread2;

    sem_init(&semFirst, 0, 1);  // Prva nit kre캖e
    sem_init(&semSecond, 0, 0); // Druga 캜eka

    pthread_create(&thread1, NULL, firstFunction, NULL);
    pthread_create(&thread2, NULL, secondFunction, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    sem_destroy(&semFirst);
    sem_destroy(&semSecond);

    return 0;
}

gcc zad2.c -o zad2 -lpthread -lm
./zad2
Thread2: -0.84 276.00
Thread1: -4.25 12.61
Thread1: 34.09 -0.45
Thread2: 1.84 -4.19
Thread2: -2.64 32.92
Thread1: 7.40 1.74
Thread2: -1.28 13.01
Thread1: -3.20 -0.39
Thread1: 14.97 -3.37
Thread2: -0.13 17.64



3. Zadan je sustav sa 4 resursa 캜iji je broj instanci definiran vektorom E = [6 5 8 7].
Pretpostavimo da je u memoriji u nekom trenutku 4 procesa (A, B, C, D) sa sljede캖om
tablicom alociranih resursa C te tablicom potrebnih resursa R.
洧낵 = (
洧냢 1 1 1 1
洧냣 2 0 1 3
洧냤 2 3 4 1
洧냥 0 0 2 0
) 洧냄 = (
洧냢 1 0 0 2
洧냣 2 1 1 2
洧냤 3 2 3 5
洧냥 2 2 2 2
)
Potrebno je provjeriti mogu li se procesi izvr코iti (je li sustav rje코iv) ili 캖e do캖i do zastoja.
Koristite Bankarev algoritam. Zadatke rije코ite ru캜no, a korake rje코enja skicirajte i
opi코ite u zada캖i na Loomenu. 


Zbrojiti sve od C

A  1 1 1 1
B  2 0 1 3
C  2 3 4 1
D  0 0 2 0
__________
=  5 4 8 5

Rezultat oduzeti od E

  6 5 8 7
- 5 4 8 5
_________
= 1 1 0 2

Redak koji se mo쬰 izvr코iti: (A)

  1 1 0 2
+ 1 1 1 1
_________
= 2 2 1 3
Izvr코en A

(B)

  2 2 1 3
+ 2 0 1 3
_________
= 4 2 2 6

Izvr코en B

(D)

  4 2 2 6
+ 0 0 2 0
_________
= 4 2 4 6

Izvr코en D

(C)

  4 2 4 6
+ 2 3 4 1
_________
= 6 5 8 7

Izvr코en C

Ne캖e do캖i do zastoja jer je rezultat jednak vektoru E (sustav je rje코iv).